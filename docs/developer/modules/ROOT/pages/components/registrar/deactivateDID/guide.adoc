= The `deactivateDID` Function

== Introduction

The `deactivateDID` function in the Hashgraph DID-SDK provides a way to deactivate existing DIDs for the Hedera DID method. This action effectively revokes the DID, making it unusable for future operations.

include::../../../shared/existing-did-updates-notes.adoc[]

== Deactivating a DID Document

To deactivate a DID, you need to provide the DID string and the client options to the `deactivateDID` function.

[source,js]
----
const clientOptions = {
  privateKey: "0x...", // Replace with your Hedera account private key
  accountId: "0.0.0....", // Replace with your Hedera account ID
  network: "testnet",
};

await deactivateDID(did, { clientOptions });
----

In this example, `deactivateDID` takes the DID to be deactivated and an object containing the `clientOptions`. This configuration object should include the necessary information to interact with the Hedera network, such as the private key, account ID, and network.

== Key Management

The `deactivateDID` function supports different key management strategies to accommodate various security needs and application architectures.

=== Internal Secret Mode

If your application manages the private key internally, you can provide it directly to the `deactivateDID` function.

[source,js]
----
await deactivateDID(did, {
  privateKey: "0x...", // Your private key
  clientOptions,
});
----

=== External Secret Mode

For enhanced security, you can use a `Signer` object to interact with an external key management system.

[source,js]
----
const signer = VaultSigner({ url, credentials }); // Configure your Signer
await deactivateDID(did, {
  signer: signer.forKey(keyId), // Specify the key to use
  clientOptions,
});
----

=== Client Managed Secret Mode

When the client application manages the private key, a specific lifecycle flow is used. This involves pausing the deactivation process on the server, sending the data to be signed to the client, and then resuming the process with the client's signature.

[source,js]
----
// Server initiates the deactivation and pauses
const pauseStep = await deactivateDID(did, {
  lifecycle: CMSMLifecycle, // Use the Client Managed Secret Mode lifecycle
  clientOptions,
});

// Server sends the data to be signed to the client
const eventBytes = pauseStep.message.eventBytes;

// Client signs the data and returns the signature
const clientSignature = await wallet.sign(eventBytes);

// Server resumes the deactivation with the client's signature
await deactivateDID(did, {
  lifecycle: CMSMLifecycle,
  from: pauseStep,
  to: { label: "signing", args: { signature: clientSignature } },
  clientOptions,
});
----

This approach allows for secure deactivation while maintaining client-side control over the private key.

== References

* xref:components-api/deactivateDID/api.adoc[`deactivateDID` API Reference]
* xref:components/signers/signer-internal/intro.adoc[Signer Reference]
* xref:components/signers/signer-external/intro.adoc[PrivateKey Reference]
* xref:components/publishers/intro.adoc[Publisher Reference]