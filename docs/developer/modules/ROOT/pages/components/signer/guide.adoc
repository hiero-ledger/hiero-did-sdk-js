= Signer

== Introduction

In the realm of decentralized identifiers (DIDs), a signer is a crucial component responsible for the secure handling of cryptographic keys and the generation of digital signatures. These signatures are essential for ensuring the authenticity and integrity of DID operations, such as creating, updating, or deactivating a DID.

The Hashgraph DID SDK provides a `Signer` interface that defines the methods for signing data, retrieving the public key, and verifying signatures. This interface allows developers to create different types of signers that can be seamlessly integrated with the SDK's DID management functionality.

== The `Signer` Interface

This interface defines methods for signing data, retrieving the public key, and verifying signatures.

[source,typescript]
----
type KeyId = string;
type PublicKeyBase58 = string;

export abstract class Signer {
  abstract sign(message: Uint8Array): Promise<Uint8Array> | Uint8Array;
  abstract getPublicKey(): Promise<PublicKeyBase58>;
  abstract verify(message: Uint8Array, signature: Uint8Array): Promise<boolean>;
}
----

=== Internal Signer Example

In this example, the `Signer` interface is implemented by the `InternalSigner` class, which utilizes Hedera keys.

[source,javascript]
----
import { PrivateKey } from "@hashgraph/sdk";
import { Signer } from "./Signer.type";

class InternalSigner implements Signer {
  private readonly privateKey: PrivateKey;

  constructor(privateKeyHex?: string) {
    this.privateKey = privateKeyHex
      ? PrivateKey.fromString(privateKeyHex)
      : PrivateKey.generateED25519();
  }

  getPublicKey(): Promise<string> {
    return Promise.resolve(this.privateKey.publicKey.toBytesBase58());
  }

  sign(message: Uint8Array): Uint8Array {
    return this.privateKey.sign(message);
  }

  async verify(message: Uint8Array, signature: Uint8Array): Promise<boolean> {
    return this.privateKey.publicKey.verify(message, signature);
  }
}

export { InternalSigner };
----

== Signer Implementations

The Hashgraph DID SDK offers various out-of-the-box signer implementations to cater to diverse key management needs:

=== Internal Signer (`@hashgraph-did-js-sdk/signer-internal`)

Suitable for environments where the application has complete control and key sensitivity is low. This implementation manages keys within the application's memory.  See the xref:https://github.com/Swiss-Digital-Assets-Institute/hashgraph-did-sdk-js/[`@hashgraph-did-js-sdk/signer-internal`] package documentation for details and usage instructions.

=== External Signer (`@hashgraph-did-js-sdk/signer-external`)

Ideal for production environments or when dealing with highly sensitive keys. This implementation delegates key management to an external Key Management System (KMS), enhancing security by offloading key storage and cryptographic operations to a specialized system. See the xref:https://github.com/Swiss-Digital-Assets-Institute/hashgraph-did-sdk-js/[`@hashgraph-did-js-sdk/signer-external`] package documentation for details and usage instructions.

=== Client-Managed Signer (`@hashgraph-did-js-sdk/signer-client`)

Offers flexibility for using preferred libraries or integrating with existing key management infrastructure. This implementation allows the client application to directly manage the keys. See the xref:https://github.com/Swiss-Digital-Assets-Institute/hashgraph-did-sdk-js/[`@hashgraph-did-js-sdk/signer-client`] package documentation for details and usage instructions.