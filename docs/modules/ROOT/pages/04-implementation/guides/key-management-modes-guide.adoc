= Hashgraph DID SDK: Key Management Modes

This guide outlines the different key management strategies supported by the DID-SDK, allowing you to choose the approach that best suits your security needs and application architecture.  Proper key management is crucial for the security and integrity of your Decentralized Identifiers (DIDs). Choose the strategy that aligns with your risk tolerance and operational requirements.

== Internal Secret Mode

In this mode, the DID-SDK generates and stores the private key within the application itself. This approach is suitable for:

* **Development and testing:** When experimenting with DIDs and the SDK.
* **Low-risk environments:** Where the security of the DID is not critical.
* **Prototyping:**  For proof-of-concept implementations.

WARNING: Avoid using this mode in production environments or when dealing with sensitive data, as it increases the risk of private key exposure.

image::internal-secret-mode-diagram.png[]

=== Creating a DID

[source,javascript]
----
const { did, didDocument } = await createDID({
  privateKey: "0x...", // Replace with your private key in DER format
  client,
});
----

Alternatively, generate a new private key:

[source,javascript]
----
const { did, didDocument } = await createDID({
  privateKey: new PrivateKey(), 
  client,
});
----

=== Updating a DID

[source,javascript]
----
const updatedDidDocument = await updateDID(did, {
  document: { ... },
  privateKey: "0x...", // Your private key
}, { clientOptions });
----

=== Deactivating a DID

[source,javascript]
----
await deactivateDID(did, {
  privateKey: "0x...", // Your private key
  clientOptions,
});
----


== External Secret Mode

This mode offers enhanced security by storing private keys externally, such as in:

* **Hardware Security Modules (HSMs):**  Provide tamper-resistant protection for keys.
* **Cloud Key Management Systems (KMS):** Offer secure, centralized key management with granular access control.

This approach is recommended for production systems and applications handling sensitive data.

image::external-secret-mode-diagram.png[]

The `Signer` object acts as an interface to your external key management system.  For example, to use a HashiCorp Vault for key storage, you would configure the `VaultSigner`:

[source,javascript]
----
const signer = VaultSigner({ url: 'your-vault-url', credentials: 'your-vault-token' }); 
----

=== Creating a DID

[source,javascript]
----
const { did, didDocument } = await createDID({
  signer: signer.forKey(keyId), // 'keyId' identifies the key in your Vault
  client,
});
----

=== Updating a DID

[source,javascript]
----
const updatedDidDocument = await updateDID(did, {
  document: { ... },
  signer: signer.forKey(keyId), 
}, { clientOptions });
----

=== Deactivating a DID

[source,javascript]
----
await deactivateDID(did, {
  signer: signer.forKey(keyId), 
  clientOptions,
});
----


== Client Managed Secret Mode

This mode delegates private key management to the client application, often within a secure wallet environment. This is suitable for scenarios where:

* **Users control their own keys:**  Providing self-sovereignty over DIDs.
* **Keys are stored in secure enclaves:**  Like mobile wallets or browser extensions.

image::client-managed-secret-mode-diagram.png[]

This mode uses a specific lifecycle flow (`CMSMLifecycle`) to facilitate secure signing by the client. 

Here's how it works:

1. **Server initiates the operation:**  The server starts the DID creation, update, or deactivation process.
2. **Server pauses for client signature:** The server generates a cryptographic challenge and sends it to the client.
3. **Client signs the challenge:** The client application (e.g., a wallet) uses the user's private key to sign the challenge.
4. **Client returns the signature:** The signed challenge is sent back to the server.
5. **Server completes the operation:** The server verifies the signature and completes the DID operation.

=== Creating a DID

[source,javascript]
----
// Server initiates lifecycle flow and pauses
const pauseStep = await createDID({
  lifecycle: CMSMLifecycle,
});

// Server sends event bytes to client for signing
const eventBytes = pauseStep.message.eventBytes;

// Client signs event bytes with wallet and returns signature
const clientSignature = await wallet.sign(eventBytes);

// Server resumes lifecycle and creates final DID
const did = await createDID({
  lifecycle: CMSMLifecycle,
  from: pauseStep,
  to: { label: "signing", args: { signature: clientSignature } },
});
----

=== Updating a DID

[source,javascript]
----
// Server initiates the update and pauses
const pauseStep = await updateDID(did, {
  document: { ... },
  lifecycle: CMSMLifecycle, 
});

// Server sends the data to be signed to the client
const eventBytes = pauseStep.message.eventBytes;

// Client signs the data and returns the signature
const clientSignature = await wallet.sign(eventBytes);

// Server resumes the update with the client's signature
const updatedDidDocument = await updateDID(did, {
  lifecycle: CMSMLifecycle,
  from: pauseStep,
  to: { label: "signing", args: { signature: clientSignature } },
}, { clientOptions });
----

=== Deactivating a DID

[source,javascript]
----
// Server initiates the deactivation and pauses
const pauseStep = await deactivateDID(did, {
  lifecycle: CMSMLifecycle, 
  clientOptions,
});

// Server sends the data to be signed to the client
const eventBytes = pauseStep.message.eventBytes;

// Client signs the data and returns the signature
const clientSignature = await wallet.sign(eventBytes);

// Server resumes the deactivation with the client's signature
await deactivateDID(did, {
  lifecycle: CMSMLifecycle,
  from: pauseStep,
  to: { label: "signing", args: { signature: clientSignature } },
  clientOptions,
});
----

== Next Steps

*   **Explore `resolveDID`:**  Dive deeper into the xref::04-implementation/components/resolveDID-guide.adoc[resolveDID] function to understand its parameters, error handling, and advanced usage.
*   **Manage DIDs:** Learn how to use xref::04-implementation/components/createDID-guide.adoc[createDID], xref::04-implementation/components/updateDID-guide.adoc[updateDID], and xref::04-implementation/components/deactivateDID-guide.adoc[deactivateDID] to effectively manage DIDs on Hedera.
*   **Implement the `Signer`:** Practice generating key pairs, signing messages, and verifying signatures using the xref::04-implementation/components/signer-guide.adoc[Signer] class.
*   **Utilize the `Publisher`:** Integrate the xref::04-implementation/components/publisher-guide.adoc[Publisher] class into your application for seamless transaction submission.